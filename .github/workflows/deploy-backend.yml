name: Deploy Backend to Azure VM

on:
  push:
    branches: [ main ]

permissions:
  contents: read
  packages: write

env:
  IMAGE_NAME: ghcr.io/${{ github.repository }}

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: docker/setup-qemu-action@v3
      - uses: docker/setup-buildx-action@v3
      - uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ secrets.GHCR_USERNAME || github.actor }}
          password: ${{ secrets.GHCR_TOKEN || github.token }}

      - name: Build and push image
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./Dockerfile
          push: true
          tags: |
            ${{ env.IMAGE_NAME }}:latest
            ${{ env.IMAGE_NAME }}:${{ github.sha }}
          cache-from: type=registry,ref=${{ env.IMAGE_NAME }}:latest
          cache-to: type=inline
          provenance: false

  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest
    steps:
      - name: Deploy over SSH to Azure VM
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.VM_HOST }}
          username: ${{ secrets.VM_USER }}
          key: ${{ secrets.VM_SSH_KEY }}
          script_stop: true
          script: |
            set -e
            
            # Install Docker if missing (fallback)
            if ! command -v docker >/dev/null 2>&1; then
              curl -fsSL https://get.docker.com | sh
              sudo usermod -aG docker $USER || true
            fi
            
            # Install Docker Compose plugin if missing (fallback)
            if ! docker compose version >/dev/null 2>&1; then
              DOCKER_COMPOSE_VERSION="v2.27.0"
              sudo mkdir -p /usr/libexec/docker/cli-plugins
              sudo curl -SL https://github.com/docker/compose/releases/download/${DOCKER_COMPOSE_VERSION}/docker-compose-linux-x86_64 -o /usr/libexec/docker/cli-plugins/docker-compose
              sudo chmod +x /usr/libexec/docker/cli-plugins/docker-compose
            fi

            # Install docker-credential-pass if pass is available
            if command -v pass >/dev/null 2>&1; then
              # Detect architecture and install correct docker-credential-pass
              ARCH=$(uname -m)
              case $ARCH in
                x86_64) ARCH_SUFFIX="linux-amd64" ;;
                aarch64|arm64) ARCH_SUFFIX="linux-arm64" ;;
                armv7l) ARCH_SUFFIX="linux-arm" ;;
                *) echo "Unsupported architecture: $ARCH" && exit 1 ;;
              esac
              
              DOCKER_CREDENTIAL_PASS_VERSION="0.6.4"
              sudo curl -L "https://github.com/docker/docker-credential-helpers/releases/download/v${DOCKER_CREDENTIAL_PASS_VERSION}/docker-credential-pass-v${DOCKER_CREDENTIAL_PASS_VERSION}-${ARCH_SUFFIX}" -o /usr/local/bin/docker-credential-pass
              sudo chmod +x /usr/local/bin/docker-credential-pass
              
              # Configure Docker to use pass
              mkdir -p ~/.docker
              echo '{"credsStore":"pass"}' | tee ~/.docker/config.json >/dev/null
            fi
            
            # Login to GHCR (credentials will be stored via pass if available)
            echo ${{ secrets.GHCR_TOKEN || github.token }} | docker login ghcr.io -u ${{ secrets.GHCR_USERNAME || github.actor }} --password-stdin

            # App home (no repo-name-specific path)
            APP_HOME=/opt/backend
            sudo mkdir -p $APP_HOME
            cd $APP_HOME

            # Write backend .env from secrets
            if [ -n "${{ secrets.BACKEND_ENV }}" ]; then
              echo "Writing backend .env from secret BACKEND_ENV"
              printf "%s" "${{ secrets.BACKEND_ENV }}" | sed 's/\r$//' | sudo tee $APP_HOME/.env >/dev/null
            else
              echo "Composing backend .env from individual GitHub Secrets"
              sudo tee $APP_HOME/.env >/dev/null <<ENV
              NODE_ENV=production
              APP_PORT=3000
              APP_NAME=${{ secrets.APP_NAME }}
              API_PREFIX=api
              APP_FALLBACK_LANGUAGE=en
              APP_HEADER_LANGUAGE=x-custom-lang

              # Database
              DATABASE_TYPE=postgres
              DATABASE_HOST=pgbouncer
              DATABASE_PORT=6432
              DATABASE_USERNAME=${{ secrets.POSTGRES_USER }}
              DATABASE_PASSWORD=${{ secrets.DATABASE_PASSWORD }}
              DATABASE_NAME=${{ secrets.DATABASE_NAME }}
              DATABASE_SYNCHRONIZE=false

              # File storage
              FILE_DRIVER=${{ secrets.FILE_DRIVER }}

              # Azure (if using azure-blob-sas)
              AZURE_STORAGE_ACCOUNT_NAME=${{ secrets.AZURE_STORAGE_ACCOUNT_NAME }}
              AZURE_STORAGE_ACCOUNT_KEY=${{ secrets.AZURE_STORAGE_ACCOUNT_KEY }}
              AZURE_CONTAINER_NAME=${{ secrets.AZURE_CONTAINER_NAME }}
              AZURE_BLOB_SAS_EXPIRY_SECONDS=3600

              # JWT (set via repo secrets or leave empty to use defaults)
              AUTH_JWT_SECRET=198enUBCbIgkGJdOySdKvfckFRJcggDVN5tD3Ly4N8c4WjZbQHRBwKVyC7uXeVD4
              AUTH_REFRESH_SECRET=NADNDwoqIsTTgGFOdc1wjidwxircxUsKOF68XnjQBQNwVB0LYr6Mw70dInXdyIH0
              AUTH_FORGOT_SECRET=FoCPY3j0q0qkvWDYXx3X4iBNRUsOQpz2uDxpj8zCAEFnoNpzi2Q7soVVnH8eRY6N
              AUTH_CONFIRM_EMAIL_SECRET=zitWttyUXHbfEE5fMy8Bxtjy7kyTmWfy4Bvxil6GBkTCYNI10YvPjA73EX8GrkyV

              # Optional domains and Zoom OAuth
              BACKEND_DOMAIN=${{ secrets.BACKEND_DOMAIN }}
              FRONTEND_DOMAIN=${{ secrets.FRONTEND_DOMAIN }}
              ZOOM_OAUTH_CLIENT_ID=${{ secrets.ZOOM_OAUTH_CLIENT_ID }}
              ZOOM_OAUTH_CLIENT_SECRET=${{ secrets.ZOOM_OAUTH_CLIENT_SECRET }}
              ZOOM_OAUTH_REDIRECT_URI=${{ secrets.ZOOM_OAUTH_REDIRECT_URI }}

              # PgBouncer tuning (optional)
              PGBOUNCER_DEFAULT_POOL_SIZE=20
              PGBOUNCER_POOL_MODE=transaction
              PGBOUNCER_MAX_CLIENT_CONN=200
              ENV
            fi

            # Create docker-compose.yml if missing or update it idempotently
            COMPOSE_FILE=$APP_HOME/docker-compose.yml
            if [ ! -f "$COMPOSE_FILE" ]; then
              echo "Creating docker-compose.yml"
              cat <<'YAML' | sudo tee $COMPOSE_FILE >/dev/null
            services:
              postgres:
                image: postgres:16
                restart: unless-stopped
                environment:
                  POSTGRES_DB: ${DATABASE_NAME}
                  POSTGRES_USER: ${DATABASE_USERNAME}
                  POSTGRES_PASSWORD: ${DATABASE_PASSWORD}
                volumes:
                  - ./postgres:/var/lib/postgresql/data

              pgbouncer:
                image: bitnami/pgbouncer:1
                restart: unless-stopped
                environment:
                  POSTGRESQL_HOST: postgres
                  POSTGRESQL_PORT_NUMBER: 5432
                  POSTGRESQL_DATABASE: ${DATABASE_NAME}
                  POSTGRESQL_USERNAME: ${DATABASE_USERNAME}
                  POSTGRESQL_PASSWORD: ${DATABASE_PASSWORD}
                  PGBOUNCER_PORT: 6432
                  PGBOUNCER_DEFAULT_POOL_SIZE: ${PGBOUNCER_DEFAULT_POOL_SIZE:-20}
                  PGBOUNCER_POOL_MODE: ${PGBOUNCER_POOL_MODE:-transaction}
                  PGBOUNCER_MAX_CLIENT_CONN: ${PGBOUNCER_MAX_CLIENT_CONN:-200}
                depends_on:
                  - postgres

              backend:
                image: ${{ env.IMAGE_NAME }}:latest
                restart: unless-stopped
                env_file:
                  - ./.env
                ports:
                  - "3000:3000"
                depends_on:
                  - pgbouncer
            YAML
            fi

            # Pull and run
            docker pull ${{ env.IMAGE_NAME }}:latest
            docker compose -f $COMPOSE_FILE up -d

            # Cleanup old images
            docker image prune -f || true

            echo "Deployment completed."


