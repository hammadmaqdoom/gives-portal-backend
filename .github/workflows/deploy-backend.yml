name: Deploy Backend to Azure VM

on:
  push:
    branches: [ main ]

permissions:
  contents: read
  packages: write

env:
  IMAGE_NAME: ghcr.io/${{ github.repository }}

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: docker/setup-qemu-action@v3
      - uses: docker/setup-buildx-action@v3
      - uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ secrets.GHCR_USERNAME || github.actor }}
          password: ${{ secrets.GHCR_TOKEN || github.token }}

      - name: Build and push image
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./Dockerfile
          push: true
          tags: |
            ${{ env.IMAGE_NAME }}:latest
            ${{ env.IMAGE_NAME }}:${{ github.sha }}
          cache-from: type=registry,ref=${{ env.IMAGE_NAME }}:latest
          cache-to: type=inline
          provenance: false

  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest
    steps:
      - name: Deploy over SSH to Azure VM
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.VM_HOST }}
          username: ${{ secrets.VM_USER }}
          key: ${{ secrets.VM_SSH_KEY }}
          script_stop: true
          script: |
            set -e
            
            echo "=== STEP 1: Starting deployment script ==="
            echo "Current working directory: $(pwd)"
            echo "Current user: $(whoami)"
            echo "Available commands: $(which docker || echo 'docker not found')"
            
            echo "=== STEP 2: Installing Docker ==="
            # Install Docker if missing (fallback)
            if ! command -v docker >/dev/null 2>&1; then
              echo "Docker not found, installing..."
              set +e  # Temporarily disable exit on error
              curl -fsSL https://get.docker.com | sh
              DOCKER_INSTALL_EXIT_CODE=$?
              set -e  # Re-enable exit on error
              
              if [ $DOCKER_INSTALL_EXIT_CODE -eq 0 ]; then
                echo "Docker installation completed successfully"
                # Add current user to docker group (skip if fails)
                CURRENT_USER=$(whoami)
                echo "Current user: $CURRENT_USER"
                set +e  # Temporarily disable exit on error
                sudo usermod -aG docker "$CURRENT_USER"
                USER_ADD_EXIT_CODE=$?
                set -e  # Re-enable exit on error
                
                if [ $USER_ADD_EXIT_CODE -eq 0 ]; then
                  echo "User added to docker group successfully"
                else
                  echo "Failed to add user to docker group, but continuing..."
                fi
              else
                echo "Docker installation failed, but continuing..."
              fi
            else
              echo "Docker already installed"
            fi
            
            echo "=== STEP 3: Installing Docker Compose ==="
            # Install Docker Compose plugin if missing (fallback)
            if ! docker compose version >/dev/null 2>&1; then
              echo "Docker Compose not found, installing..."
              DOCKER_COMPOSE_VERSION="v2.27.0"
              sudo mkdir -p /usr/libexec/docker/cli-plugins
              sudo curl -SL https://github.com/docker/compose/releases/download/${DOCKER_COMPOSE_VERSION}/docker-compose-linux-x86_64 -o /usr/libexec/docker/cli-plugins/docker-compose
              sudo chmod +x /usr/libexec/docker/cli-plugins/docker-compose
            else
              echo "Docker Compose already installed"
            fi

            echo "=== STEP 4: Installing docker-credential-pass ==="
            # Install docker-credential-pass if pass is available
            if command -v pass >/dev/null 2>&1; then
              echo "Pass found, installing docker-credential-pass..."
              # Detect architecture and install correct docker-credential-pass
              ARCH=$(uname -m)
              case $ARCH in
                x86_64) ARCH_SUFFIX="linux-amd64" ;;
                aarch64|arm64) ARCH_SUFFIX="linux-arm64" ;;
                armv7l) ARCH_SUFFIX="linux-arm" ;;
                *) echo "Unsupported architecture: $ARCH" && exit 1 ;;
              esac
              
              DOCKER_CREDENTIAL_PASS_VERSION="0.6.4"
              sudo curl -L "https://github.com/docker/docker-credential-helpers/releases/download/v${DOCKER_CREDENTIAL_PASS_VERSION}/docker-credential-pass-v${DOCKER_CREDENTIAL_PASS_VERSION}-${ARCH_SUFFIX}" -o /usr/local/bin/docker-credential-pass
              sudo chmod +x /usr/local/bin/docker-credential-pass
              
              # Configure Docker to use pass
              mkdir -p ~/.docker
              echo '{"credsStore":"pass"}' | tee ~/.docker/config.json >/dev/null
              echo "docker-credential-pass installed and configured"
            else
              echo "Pass not found, skipping credential helper"
            fi
            
            echo "=== STEP 5: Logging into GHCR ==="
            # Login to GHCR (credentials will be stored via pass if available)
            echo "${{ secrets.GHCR_TOKEN || github.token }}" | docker login ghcr.io -u "${{ secrets.GHCR_USERNAME || github.actor }}" --password-stdin
            echo "Successfully logged into GHCR"

            echo "=== STEP 6: Setting up app directory ==="
            # App home (no repo-name-specific path)
            APP_HOME=/opt/backend
            sudo mkdir -p $APP_HOME
            cd $APP_HOME
            echo "App directory set to: $APP_HOME"

            echo "=== STEP 7: Creating .env file ==="
            # Write backend .env from secrets
            if [ -n "${{ secrets.BACKEND_ENV }}" ]; then
              echo "Writing backend .env from secret BACKEND_ENV"
              printf "%s" "${{ secrets.BACKEND_ENV }}" | sed 's/\r$//' | sudo tee $APP_HOME/.env >/dev/null
              echo "Backend .env created from BACKEND_ENV secret"
            else
              echo "Composing backend .env from individual GitHub Secrets"
              {
                echo "NODE_ENV=production"
                echo "APP_PORT=3000"
                echo "APP_NAME=${{ secrets.APP_NAME }}"
                echo "API_PREFIX=api"
                echo "APP_FALLBACK_LANGUAGE=en"
                echo "APP_HEADER_LANGUAGE=x-custom-lang"
                echo ""
                echo "# Database"
                echo "DATABASE_TYPE=postgres"
                echo "DATABASE_HOST=pgbouncer"
                echo "DATABASE_PORT=6432"
                echo "DATABASE_USERNAME=${{ secrets.POSTGRES_USER }}"
                echo "DATABASE_PASSWORD=${{ secrets.DATABASE_PASSWORD }}"
                echo "DATABASE_NAME=${{ secrets.DATABASE_NAME }}"
                echo "DATABASE_SYNCHRONIZE=false"
                echo ""
                echo "# File storage"
                echo "FILE_DRIVER=${{ secrets.FILE_DRIVER }}"
                echo ""
                echo "# Azure (if using azure-blob-sas)"
                echo "AZURE_STORAGE_ACCOUNT_NAME=${{ secrets.AZURE_STORAGE_ACCOUNT_NAME }}"
                echo "AZURE_STORAGE_ACCOUNT_KEY=${{ secrets.AZURE_STORAGE_ACCOUNT_KEY }}"
                echo "AZURE_CONTAINER_NAME=${{ secrets.AZURE_CONTAINER_NAME }}"
                echo "AZURE_BLOB_SAS_EXPIRY_SECONDS=3600"
                echo ""
                echo "# JWT (set via repo secrets or leave empty to use defaults)"
                echo "AUTH_JWT_SECRET=${{ secrets.AUTH_JWT_SECRET }}"
                echo "AUTH_REFRESH_SECRET=${{ secrets.AUTH_REFRESH_SECRET }}"
                echo "AUTH_FORGOT_SECRET=${{ secrets.AUTH_FORGOT_SECRET }}"
                echo "AUTH_CONFIRM_EMAIL_SECRET=${{ secrets.AUTH_CONFIRM_EMAIL_SECRET }}"
                echo ""
                echo "# Optional domains and Zoom OAuth"
                echo "BACKEND_DOMAIN=${{ secrets.BACKEND_DOMAIN }}"
                echo "FRONTEND_DOMAIN=${{ secrets.FRONTEND_DOMAIN }}"
                echo "ZOOM_OAUTH_CLIENT_ID=${{ secrets.ZOOM_OAUTH_CLIENT_ID }}"
                echo "ZOOM_OAUTH_CLIENT_SECRET=${{ secrets.ZOOM_OAUTH_CLIENT_SECRET }}"
                echo "ZOOM_OAUTH_REDIRECT_URI=${{ secrets.ZOOM_OAUTH_REDIRECT_URI }}"
                echo ""
                echo "# PgBouncer tuning (optional)"
                echo "PGBOUNCER_DEFAULT_POOL_SIZE=20"
                echo "PGBOUNCER_POOL_MODE=transaction"
                echo "PGBOUNCER_MAX_CLIENT_CONN=200"
              } | sudo tee $APP_HOME/.env >/dev/null
              echo "Backend .env created from individual secrets"
            fi

            echo "=== STEP 8: Creating docker-compose.yml ==="
            # Create docker-compose.yml if missing or update it idempotently
            COMPOSE_FILE=$APP_HOME/docker-compose.yml
            if [ ! -f "$COMPOSE_FILE" ]; then
              echo "Creating docker-compose.yml"
              {
                echo "services:"
                echo "  postgres:"
                echo "    image: postgres:16"
                echo "    restart: unless-stopped"
                echo "    environment:"
                echo "      POSTGRES_DB: \${DATABASE_NAME}"
                echo "      POSTGRES_USER: \${DATABASE_USERNAME}"
                echo "      POSTGRES_PASSWORD: \${DATABASE_PASSWORD}"
                echo "    volumes:"
                echo "      - ./postgres:/var/lib/postgresql/data"
                echo ""
                echo "  pgbouncer:"
                echo "    image: bitnami/pgbouncer:1"
                echo "    restart: unless-stopped"
                echo "    environment:"
                echo "      POSTGRESQL_HOST: postgres"
                echo "      POSTGRESQL_PORT_NUMBER: 5432"
                echo "      POSTGRESQL_DATABASE: \${DATABASE_NAME}"
                echo "      POSTGRESQL_USERNAME: \${DATABASE_USERNAME}"
                echo "      POSTGRESQL_PASSWORD: \${DATABASE_PASSWORD}"
                echo "      PGBOUNCER_PORT: 6432"
                echo "      PGBOUNCER_DEFAULT_POOL_SIZE: \${PGBOUNCER_DEFAULT_POOL_SIZE:-20}"
                echo "      PGBOUNCER_POOL_MODE: \${PGBOUNCER_POOL_MODE:-transaction}"
                echo "      PGBOUNCER_MAX_CLIENT_CONN: \${PGBOUNCER_MAX_CLIENT_CONN:-200}"
                echo "    depends_on:"
                echo "      - postgres"
                echo ""
                echo "  backend:"
                echo "    image: ghcr.io/hammadmaqdoom/gives-portal-backend:latest"
                echo "    restart: unless-stopped"
                echo "    env_file:"
                echo "      - ./.env"
                echo "    ports:"
                echo "      - \"3000:3000\""
                echo "    depends_on:"
                echo "      - pgbouncer"
              } | sudo tee $COMPOSE_FILE >/dev/null
              echo "docker-compose.yml created successfully"
            else
              echo "docker-compose.yml already exists"
            fi

            echo "=== STEP 9: Pulling Docker image ==="
            # Pull and run
            docker pull "${{ env.IMAGE_NAME }}:latest"
            echo "Docker image pulled successfully"

            echo "=== STEP 10: Starting services ==="
            docker compose -f $COMPOSE_FILE up -d
            echo "Services started successfully"

            echo "=== STEP 11: Cleanup ==="
            # Cleanup old images
            docker image prune -f || true
            echo "Old images cleaned up"

            echo "=== DEPLOYMENT COMPLETED SUCCESSFULLY ==="


