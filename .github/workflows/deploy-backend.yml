name: Deploy Backend to Azure VM

on:
  push:
    branches: [ main ]

permissions:
  contents: read
  packages: write

env:
  IMAGE_NAME: ghcr.io/${{ github.repository }}

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: docker/setup-qemu-action@v3
      - uses: docker/setup-buildx-action@v3
      - uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ secrets.GHCR_USERNAME || github.actor }}
          password: ${{ secrets.GHCR_TOKEN || github.token }}

      - name: Build and push image
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./Dockerfile
          push: true
          tags: |
            ${{ env.IMAGE_NAME }}:latest
            ${{ env.IMAGE_NAME }}:${{ github.sha }}
          cache-from: type=registry,ref=${{ env.IMAGE_NAME }}:latest
          cache-to: type=inline
          provenance: false

  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest
    steps:
      - name: Deploy over SSH to Azure VM
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.VM_HOST }}
          username: ${{ secrets.VM_USER }}
          key: ${{ secrets.VM_SSH_KEY }}
          script_stop: true
          script: |
            set -e
            
            echo "=== STEP 1: Starting deployment script ==="
            echo "Current working directory: $(pwd)"
            echo "Current user: $(whoami)"
            echo "Available commands: $(which docker || echo 'docker not found')"
            
            echo "=== STEP 2: Checking Docker ==="
            # Check if Docker is available
            if command -v docker >/dev/null 2>&1; then
              echo "Docker is already installed and available"
              docker --version
            else
              echo "Docker not found, but skipping installation as requested"
            fi
            
            echo "=== STEP 3: Checking Docker Compose ==="
            # Check if Docker Compose is available
            if docker compose version >/dev/null 2>&1; then
              echo "Docker Compose is already installed and available"
              docker compose version
            else
              echo "Docker Compose not found, but skipping installation as requested"
            fi

            echo "=== STEP 4: Ensuring docker-credential-pass (with correct architecture) ==="
            # Ensure docker-credential-pass exists and is executable for this architecture
            NEED_INSTALL_HELPER=false
            if command -v docker-credential-pass >/dev/null 2>&1; then
              echo "docker-credential-pass found at: $(command -v docker-credential-pass)"
              # Try executing a harmless command; if it fails (e.g., exec format error), replace it
              if ! docker-credential-pass list >/dev/null 2>&1; then
                echo "Existing docker-credential-pass fails to execute; will replace with correct architecture"
                NEED_INSTALL_HELPER=true
              else
                echo "docker-credential-pass executes correctly; keeping existing binary"
              fi
            else
              echo "docker-credential-pass not found; will install"
              NEED_INSTALL_HELPER=true
            fi

            if [ "$NEED_INSTALL_HELPER" = true ]; then
              ARCH=$(uname -m)
              case $ARCH in
                x86_64) ARCH_SUFFIX="linux-amd64" ;;
                aarch64|arm64) ARCH_SUFFIX="linux-arm64" ;;
                armv7l) ARCH_SUFFIX="linux-arm" ;;
                *) echo "Unsupported architecture: $ARCH" && exit 1 ;;
              esac
              DOCKER_CREDENTIAL_PASS_VERSION="0.6.4"
              DOWNLOAD_URL="https://github.com/docker/docker-credential-helpers/releases/download/v${DOCKER_CREDENTIAL_PASS_VERSION}/docker-credential-pass-v${DOCKER_CREDENTIAL_PASS_VERSION}-${ARCH_SUFFIX}"
              echo "Downloading docker-credential-pass from: $DOWNLOAD_URL"
              sudo curl -fsSL "$DOWNLOAD_URL" -o /usr/local/bin/docker-credential-pass
              sudo chmod +x /usr/local/bin/docker-credential-pass
              # Verify it runs now
              if ! /usr/local/bin/docker-credential-pass list >/dev/null 2>&1; then
                echo "docker-credential-pass still not executable; aborting"
                exit 1
              fi
              echo "docker-credential-pass installed and validated"
            fi

            echo "=== STEP 5: Configure Docker to use pass and login to GHCR ==="
            # Docker config is expected to already have credsStore=pass; keep existing without overwriting
            mkdir -p ~/.docker
            if [ -f ~/.docker/config.json ]; then
              echo "Docker config exists; not overwriting credsStore"
            fi

            # Login to GHCR using pass helper (no plaintext stored)
            echo "${{ secrets.GHCR_TOKEN || github.token }}" | docker login ghcr.io -u "${{ secrets.GHCR_USERNAME || github.actor }}" --password-stdin
            echo "Successfully logged into GHCR with pass credential store"
            
            echo "=== STEP 6: Setting up app directory ==="
            # App home (no repo-name-specific path)
            APP_HOME=/opt/backend
            sudo mkdir -p $APP_HOME
            cd $APP_HOME
            echo "App directory set to: $APP_HOME"

            echo "=== STEP 7: Creating .env file ==="
            # Write backend .env from secrets
            if [ -n "${{ secrets.BACKEND_ENV }}" ]; then
              echo "Writing backend .env from secret BACKEND_ENV"
              printf "%s" "${{ secrets.BACKEND_ENV }}" | sed 's/\r$//' | sudo tee $APP_HOME/.env >/dev/null
              echo "Backend .env created from BACKEND_ENV secret"
            else
              echo "Composing backend .env from individual GitHub Secrets"
              {
                echo "NODE_ENV=production"
                echo "APP_PORT=3000"
                echo "APP_NAME=${{ secrets.APP_NAME }}"
                echo "API_PREFIX=api"
                echo "APP_FALLBACK_LANGUAGE=en"
                echo "APP_HEADER_LANGUAGE=x-custom-lang"
                echo ""
                echo "# Database"
                echo "DATABASE_TYPE=postgres"
                echo "DATABASE_HOST=pgbouncer"
                echo "DATABASE_PORT=6432"
                echo "DATABASE_USERNAME=${{ secrets.POSTGRES_USER }}"
                echo "DATABASE_PASSWORD=${{ secrets.DATABASE_PASSWORD }}"
                echo "DATABASE_NAME=${{ secrets.DATABASE_NAME }}"
                echo "DATABASE_SYNCHRONIZE=false"
                echo ""
                echo "# File storage"
                echo "FILE_DRIVER=${{ secrets.FILE_DRIVER }}"
                echo ""
                echo "# Azure (if using azure-blob-sas)"
                echo "AZURE_STORAGE_ACCOUNT_NAME=${{ secrets.AZURE_STORAGE_ACCOUNT_NAME }}"
                echo "AZURE_STORAGE_ACCOUNT_KEY=${{ secrets.AZURE_STORAGE_ACCOUNT_KEY }}"
                echo "AZURE_CONTAINER_NAME=${{ secrets.AZURE_CONTAINER_NAME }}"
                echo "AZURE_BLOB_SAS_EXPIRY_SECONDS=3600"
                echo ""
                echo "# JWT (set via repo secrets or leave empty to use defaults)"
                echo "AUTH_JWT_SECRET=${{ secrets.AUTH_JWT_SECRET }}"
                echo "AUTH_REFRESH_SECRET=${{ secrets.AUTH_REFRESH_SECRET }}"
                echo "AUTH_FORGOT_SECRET=${{ secrets.AUTH_FORGOT_SECRET }}"
                echo "AUTH_CONFIRM_EMAIL_SECRET=${{ secrets.AUTH_CONFIRM_EMAIL_SECRET }}"
                echo ""
                echo "# Optional domains and Zoom OAuth"
                echo "BACKEND_DOMAIN=${{ secrets.BACKEND_DOMAIN }}"
                echo "FRONTEND_DOMAIN=${{ secrets.FRONTEND_DOMAIN }}"
                echo "ZOOM_OAUTH_CLIENT_ID=${{ secrets.ZOOM_OAUTH_CLIENT_ID }}"
                echo "ZOOM_OAUTH_CLIENT_SECRET=${{ secrets.ZOOM_OAUTH_CLIENT_SECRET }}"
                echo "ZOOM_OAUTH_REDIRECT_URI=${{ secrets.ZOOM_OAUTH_REDIRECT_URI }}"
                echo ""
                echo "# PgBouncer tuning (optional)"
                echo "PGBOUNCER_DEFAULT_POOL_SIZE=20"
                echo "PGBOUNCER_POOL_MODE=transaction"
                echo "PGBOUNCER_MAX_CLIENT_CONN=200"
              } | sudo tee $APP_HOME/.env >/dev/null
              echo "Backend .env created from individual secrets"
            fi

            echo "=== STEP 8: Creating docker-compose.yml ==="
            # Create docker-compose.yml if missing or update it idempotently
            COMPOSE_FILE=$APP_HOME/docker-compose.yml
            if [ ! -f "$COMPOSE_FILE" ]; then
              echo "Creating docker-compose.yml"
              {
                echo "services:"
                echo "  postgres:"
                echo "    image: postgres:16"
                echo "    restart: unless-stopped"
                echo "    environment:"
                echo "      POSTGRES_DB: \${DATABASE_NAME}"
                echo "      POSTGRES_USER: \${DATABASE_USERNAME}"
                echo "      POSTGRES_PASSWORD: \${DATABASE_PASSWORD}"
                echo "    volumes:"
                echo "      - ./postgres:/var/lib/postgresql/data"
                echo ""
                echo "  pgbouncer:"
                echo "    image: bitnami/pgbouncer:1"
                echo "    restart: unless-stopped"
                echo "    environment:"
                echo "      POSTGRESQL_HOST: postgres"
                echo "      POSTGRESQL_PORT_NUMBER: 5432"
                echo "      POSTGRESQL_DATABASE: \${DATABASE_NAME}"
                echo "      POSTGRESQL_USERNAME: \${DATABASE_USERNAME}"
                echo "      POSTGRESQL_PASSWORD: \${DATABASE_PASSWORD}"
                echo "      PGBOUNCER_PORT: 6432"
                echo "      PGBOUNCER_DEFAULT_POOL_SIZE: \${PGBOUNCER_DEFAULT_POOL_SIZE:-20}"
                echo "      PGBOUNCER_POOL_MODE: \${PGBOUNCER_POOL_MODE:-transaction}"
                echo "      PGBOUNCER_MAX_CLIENT_CONN: \${PGBOUNCER_MAX_CLIENT_CONN:-200}"
                echo "    depends_on:"
                echo "      - postgres"
                echo ""
                echo "  backend:"
                echo "    image: ghcr.io/hammadmaqdoom/gives-portal-backend:latest"
                echo "    restart: unless-stopped"
                echo "    env_file:"
                echo "      - ./.env"
                echo "    ports:"
                echo "      - \"3000:3000\""
                echo "    depends_on:"
                echo "      - pgbouncer"
              } | sudo tee $COMPOSE_FILE >/dev/null
              echo "docker-compose.yml created successfully"
            else
              echo "docker-compose.yml already exists"
            fi

            echo "=== STEP 9: Pulling Docker image ==="
            # Pull and run
            docker pull "${{ env.IMAGE_NAME }}:latest"
            echo "Docker image pulled successfully"

            echo "=== STEP 10: Starting services ==="
            docker compose -f $COMPOSE_FILE up -d
            echo "Services started successfully"

            echo "=== STEP 11: Cleanup ==="
            # Cleanup old images
            docker image prune -f || true
            echo "Old images cleaned up"

            echo "=== DEPLOYMENT COMPLETED SUCCESSFULLY ==="


