name: Distribute updates to client repos

on:
  push:
    branches: [ "main" ]
  workflow_dispatch:

permissions:
  contents: write
  pull-requests: write

jobs:
  fanout:
    # Only run on main repository, not on client repos
    # Skip if this is a client repo (silveracademy-backend, etc.)
    # Only run if this is the main LMS Portal repository
    if: |
      !contains(github.repository, 'silveracademy') &&
      !contains(github.repository, 'client-') &&
      (contains(github.repository, 'lms-portal') || 
       github.repository == 'hammadmaqdoom/LMS Portal - Main' ||
       github.repository == 'hammadmaqdoom/lms-portal-backend')
    runs-on: ubuntu-latest
    env:
      GH_TOKEN: ${{ secrets.CLIENT_SYNC_TOKEN }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Need full history for proper syncing

      - name: Install yq
        run: |
          sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/download/v4.44.3/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq

      - name: Convert clients.yml to JSON
        id: clients_json
        run: |
          yq -o=json '.clients' clients.yml > clients.json
          echo "json<<EOF" >> $GITHUB_OUTPUT
          cat clients.json >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Process clients
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.GH_TOKEN }}
          script: |
            const fs = require('fs');
            const { execSync } = require('child_process');
            
            // Read clients.json (converted from YAML)
            const clientsJson = fs.readFileSync('clients.json', 'utf8');
            const clients = JSON.parse(clientsJson);
            
            const owner = context.repo.owner;  // e.g., "hammadmaqdoom"
            const repo = context.repo.repo;   // e.g., "lms-portal-backend" (base backend repo)
            const baseBranch = 'main';
            const syncBranch = 'syncing';  // Fixed branch name for syncing
            const defaultBranch = 'main';  // Always use main as default branch
            
            for (const c of clients) {
              const targetOwner = c.org;
              const targetRepo = c.repo;
              const targetBranch = c.target_branch || 'staging';
              const sentryDsn = c.sentry_dsn || '';
              
              try {
                console.log(`\nüì¶ Processing ${targetOwner}/${targetRepo}...`);
                if (sentryDsn) {
                  console.log(`üîî Sentry DSN configured for this client`);
                }
                
                const tempDir = `/tmp/sync-${targetRepo}-${Date.now()}`;
                
                // Clone client repo
                execSync(`git clone https://${process.env.GH_TOKEN}@github.com/${targetOwner}/${targetRepo}.git ${tempDir}`, {
                  stdio: 'inherit',
                  env: { ...process.env, GIT_TERMINAL_PROMPT: '0' }
                });
                
                process.chdir(tempDir);
                
                // Configure git
                execSync('git config user.name "github-actions[bot]"', { stdio: 'inherit' });
                execSync('git config user.email "github-actions[bot]@users.noreply.github.com"', { stdio: 'inherit' });
                
                // Check if repo is empty (no branches or no commits)
                let isEmpty = false;
                try {
                  const branchOutput = execSync('git branch -a', { encoding: 'utf8' });
                  const refsOutput = execSync('git show-ref', { encoding: 'utf8' });
                  isEmpty = (branchOutput.trim().length === 0 || refsOutput.trim().length === 0);
                } catch (e) {
                  isEmpty = true; // If git commands fail, repo is likely empty
                }
                
                if (isEmpty) {
                  console.log('üì¶ Repo is empty, initializing with main and staging branches...');
                  // Create initial commit on main
                  execSync('git checkout -b main', { stdio: 'inherit' });
                  execSync('git commit --allow-empty -m "Initial commit"', { stdio: 'inherit' });
                  execSync(`git push origin main`, { stdio: 'inherit' });
                  
                  // Create staging branch from main
                  execSync(`git checkout -b ${targetBranch}`, { stdio: 'inherit' });
                  execSync(`git push origin ${targetBranch}`, { stdio: 'inherit' });
                  
                  console.log(`‚úÖ Created ${defaultBranch} and ${targetBranch} branches`);
                } else {
                  // Repo has content - ensure main branch exists
                  try {
                    execSync(`git checkout ${defaultBranch}`, { stdio: 'inherit' });
                  } catch (e) {
                    // Main branch doesn't exist, create it from current branch or create new
                    try {
                      const currentBranch = execSync('git branch --show-current', { encoding: 'utf8' }).trim();
                      if (currentBranch) {
                        execSync(`git checkout -b ${defaultBranch}`, { stdio: 'inherit' });
                      } else {
                        execSync(`git checkout -b ${defaultBranch}`, { stdio: 'inherit' });
                        execSync('git commit --allow-empty -m "Initial main branch"', { stdio: 'inherit' });
                      }
                    } catch (e) {
                      execSync(`git checkout -b ${defaultBranch}`, { stdio: 'inherit' });
                      execSync('git commit --allow-empty -m "Initial main branch"', { stdio: 'inherit' });
                    }
                  }
                  
                  // Ensure staging branch exists
                  try {
                    execSync(`git checkout ${targetBranch}`, { stdio: 'inherit' });
                  } catch (e) {
                    // Create staging branch from main
                    execSync(`git checkout ${defaultBranch}`, { stdio: 'inherit' });
                    execSync(`git checkout -b ${targetBranch}`, { stdio: 'inherit' });
                  }
                }
                
                // Add base repo as remote and fetch
                try {
                  execSync(`git remote add upstream https://${process.env.GH_TOKEN}@github.com/${owner}/${repo}.git`, { stdio: 'inherit' });
                } catch (e) {
                  execSync('git remote remove upstream', { stdio: 'inherit' });
                  execSync(`git remote add upstream https://${process.env.GH_TOKEN}@github.com/${owner}/${repo}.git`, { stdio: 'inherit' });
                }
                
                // Ensure main and staging branches are pushed to remote
                if (isEmpty) {
                  // Already pushed during initialization
                  execSync(`git checkout ${defaultBranch}`, { stdio: 'inherit' });
                } else {
                  // Ensure branches are pushed
                  execSync(`git checkout ${defaultBranch}`, { stdio: 'inherit' });
                  try {
                    execSync(`git push origin ${defaultBranch}`, { stdio: 'inherit' });
                  } catch (e) {
                    console.log('Main branch already exists remotely');
                  }
                  
                  execSync(`git checkout ${targetBranch}`, { stdio: 'inherit' });
                  try {
                    execSync(`git push origin ${targetBranch}`, { stdio: 'inherit' });
                  } catch (e) {
                    console.log('Staging branch already exists remotely');
                  }
                }
                
                // Add base repo as remote and fetch
                try {
                  execSync(`git remote add upstream https://${process.env.GH_TOKEN}@github.com/${owner}/${repo}.git`, { stdio: 'inherit' });
                } catch (e) {
                  execSync('git remote remove upstream', { stdio: 'inherit' });
                  execSync(`git remote add upstream https://${process.env.GH_TOKEN}@github.com/${owner}/${repo}.git`, { stdio: 'inherit' });
                }
                
                execSync('git fetch upstream main', { stdio: 'inherit' });
                
                // Create or checkout syncing branch from main
                execSync(`git checkout ${defaultBranch}`, { stdio: 'inherit' });
                try {
                  execSync(`git checkout -b ${syncBranch}`, { stdio: 'inherit' });
                } catch (e) {
                  execSync(`git checkout ${syncBranch}`, { stdio: 'inherit' });
                }
                
                // Merge upstream/main into syncing branch (allow unrelated histories if needed)
                try {
                  execSync(`git merge upstream/main --no-edit --allow-unrelated-histories`, { stdio: 'inherit' });
                } catch (e) {
                  console.log('Merge had conflicts or issues, but continuing...');
                }
                
                // Inject Sentry DSN into .env file if provided
                if (sentryDsn) {
                  try {
                    const envPath = '.env';
                    let envContent = '';
                    
                    // Read existing .env if it exists
                    if (fs.existsSync(envPath)) {
                      envContent = fs.readFileSync(envPath, 'utf8');
                    }
                    
                    // Update or add SENTRY_DSN
                    if (envContent.includes('SENTRY_DSN=')) {
                      // Replace existing SENTRY_DSN
                      envContent = envContent.replace(
                        /SENTRY_DSN=.*/g,
                        `SENTRY_DSN=${sentryDsn}`
                      );
                    } else {
                      // Append SENTRY_DSN if not present
                      envContent += (envContent.endsWith('\n') ? '' : '\n') + `SENTRY_DSN=${sentryDsn}\n`;
                    }
                    
                    // Ensure SENTRY_ENABLED is set
                    if (!envContent.includes('SENTRY_ENABLED=')) {
                      envContent += `SENTRY_ENABLED=true\n`;
                    } else {
                      envContent = envContent.replace(
                        /SENTRY_ENABLED=.*/g,
                        'SENTRY_ENABLED=true'
                      );
                    }
                    
                    // Write updated .env
                    fs.writeFileSync(envPath, envContent);
                    
                    // Commit the .env update
                    try {
                      execSync('git add .env', { stdio: 'inherit' });
                      execSync('git commit -m "chore: update Sentry DSN from upstream distribution"', { stdio: 'inherit' });
                      console.log('‚úÖ Updated .env with Sentry DSN');
                    } catch (commitError) {
                      // If commit fails (no changes or already committed), that's okay
                      console.log('‚ÑπÔ∏è  .env update already committed or no changes');
                    }
                  } catch (envError) {
                    console.warn(`‚ö†Ô∏è  Failed to update .env with Sentry DSN: ${envError.message}`);
                    // Continue even if .env update fails
                  }
                }
                
                // Push sync branch
                try {
                  execSync(`git push origin ${syncBranch} --force`, { stdio: 'inherit' });
                } catch (e) {
                  console.error('Failed to push:', e.message);
                  throw e;
                }
                
                // Attempt to fast-forward target branch directly
                let autoMerged = false;
                let syncHasUpdates = true;
                try {
                  const diff = execSync(`git rev-list ${targetBranch}..${syncBranch}`, { encoding: 'utf8' }).trim();
                  syncHasUpdates = diff.length > 0;
                } catch (e) {
                  syncHasUpdates = true;
                }
                
                if (syncHasUpdates) {
                  try {
                    console.log(`üîÅ Attempting to auto-merge ${syncBranch} into ${targetBranch}`);
                    execSync(`git checkout ${targetBranch}`, { stdio: 'inherit' });
                    execSync(`git merge ${syncBranch} --no-edit`, { stdio: 'inherit' });
                    execSync(`git push origin ${targetBranch}`, { stdio: 'inherit' });
                    autoMerged = true;
                    console.log(`‚úÖ Auto-merged latest upstream changes into ${targetBranch}`);
                  } catch (mergeError) {
                    console.warn(`‚ö†Ô∏è  Auto-merge failed for ${targetOwner}/${targetRepo}: ${mergeError.message}`);
                    try {
                      execSync('git merge --abort', { stdio: 'inherit' });
                    } catch (abortError) {
                      // Ignore if there was nothing to abort
                    }
                    execSync(`git checkout ${syncBranch}`, { stdio: 'inherit' });
                  }
                } else {
                  console.log('‚ÑπÔ∏è  No new commits to merge; target branch already up to date.');
                }
                
                if (!autoMerged && syncHasUpdates) {
                  // Create PR from syncing branch to staging branch
                  try {
                    const pr = await github.rest.pulls.create({
                      owner: targetOwner,
                      repo: targetRepo,
                      title: `[Upstream Sync] ${owner}/${repo}@${context.sha.substring(0, 7)} ‚Üí ${targetBranch}`,
                      head: syncBranch,
                      base: targetBranch,
                      body: `## üîÑ Automated Upstream Sync\n\n` +
                            `Auto-merge attempt failed; manual review required.\n\n` +
                            `- **Source**: \`${owner}/${repo}@${context.sha.substring(0, 7)}\`\n` +
                            `- **Target**: \`${targetBranch}\` branch\n` +
                            `- **Base Commit**: ${context.sha}\n\n` +
                            `Resolve conflicts (if any) and merge to keep client repo in sync.`,
                      maintainer_can_modify: true
                    });
                    console.log(`‚úÖ Opened PR #${pr.data.number}: ${pr.data.html_url}`);
                  } catch (e) {
                    if (e.status === 422) {
                      if (/No commits between/.test(e.message)) {
                        console.log(`‚ÑπÔ∏è  No changes to sync - repos are already in sync`);
                      } else if (/already exists/i.test(e.message)) {
                        const existingPRs = await github.rest.pulls.list({
                          owner: targetOwner,
                          repo: targetRepo,
                          state: 'open',
                          head: `${targetOwner}:${syncBranch}`,
                          base: targetBranch
                        });
                        if (existingPRs.data.length > 0) {
                          console.log(`‚ÑπÔ∏è  PR already exists: #${existingPRs.data[0].number}`);
                        } else {
                          const allPRs = await github.rest.pulls.list({
                            owner: targetOwner,
                            repo: targetRepo,
                            state: 'open',
                            base: targetBranch
                          });
                          console.log(`‚ÑπÔ∏è  Found ${allPRs.data.length} open PR(s) to ${targetBranch}`);
                        }
                      } else {
                        console.warn(`‚ö†Ô∏è  PR creation issue: ${e.message}`);
                      }
                    } else {
                      throw e;
                    }
                  }
                } else if (autoMerged) {
                  console.log(`üéâ ${targetOwner}/${targetRepo}:${targetBranch} is now in sync with upstream without manual intervention.`);
                }
                
                // Cleanup
                process.chdir('/');
                execSync(`rm -rf ${tempDir}`, { stdio: 'inherit' });
                
              } catch (error) {
                console.error(`‚ùå Error processing ${targetOwner}/${targetRepo}:`, error.message);
                // Cleanup on error
                try {
                  process.chdir('/');
                  execSync(`rm -rf /tmp/sync-${targetRepo}-*`, { stdio: 'inherit' });
                } catch (e) {}
                // Don't fail entire workflow
              }
            }

